class single_train:
    '''
    many trains are generated by one control point,
    here I want to output the schedule of each train.
    '''

    def __init__(self, begin, end, is_DoS, DoS_begin, DoS_end, DoS_block, siding, block):
        # the position of siding. ps: siding is a list of integer
        self.siding = siding
        # self.block is the length of each block
        self.block = block
        self.refresh = 2
        self.all_schedule = {}
        # begin and end are string, the format is '2018-01-01 00:00:00'
        self.T = time
        # turn begin and end into the number ticks from 1970 to now.
        self.begin_ticks = time.mktime(time.strptime(begin, "%Y-%m-%d %H:%M:%S"))
        self.end_ticks = time.mktime(time.strptime(end, "%Y-%m-%d %H:%M:%S"))
        # information of DoS
        self.is_DoS = is_DoS
        self.DoS_begin_ticks = time.mktime(time.strptime(DoS_begin, "%Y-%m-%d %H:%M:%S"))
        self.DoS_end_ticks = time.mktime(time.strptime(DoS_end, "%Y-%m-%d %H:%M:%S"))
        self.DoS_block = DoS_block
        # self.number is the number of refresh.
        self.number = 1
        # we get a new self.one_schedule after each refresh
        self.one_schedule = {}
        self.one_detail = {}
        self.speed = {}
        # parameter of headway
        self.headway_exp = 20
        self.headway_dev = 5
        # distance of each train
        ## distance means x-axis coordinates
        self.distance = collections.defaultdict(int)
        self.cur_block = collections.defaultdict(int)
        self.sum_block_dis = collections.defaultdict(int)
        ## trick to avoid KeyError when the key is not existed.
        ## distance is the dictionary for trains with the Key Value as train indices (integers)

        self.time = {1: self.begin_ticks}
        ## time is the dictionary for trains with with the Key Value as train indices (integers)
        self.G = nx.read_gpickle("a.gpickle")
        self.pos = nx.get_node_attributes(self.G, 'pos')
        # self.labels = collections.defaultdict()
        self.labels = {}
        self.pos_labels = {}
        # define which siding that late/fast train surpass previous/slow trains
        self.isPass = defaultdict(lambda: float('inf'))
        # in order to solve problem: the number of trains is not the rank of trains. I use dict rank[n]
        self.rank = collections.defaultdict(int)
        self.weight = collections.defaultdict(int)


        # use simpy library to define the process of train system
        env = simpy.Environment()
        env.process(self.train(env))
        duration = self.end_ticks - self.begin_ticks
        env.run(until=duration)

    def train(self, env):
        # ranking is used for find which train will be surpass next
        rank = {}
        for i in range(1000):
            rank[i] = i

        # define the serial number of block which have siding
        Number_siding = []
        for c in self.siding:
            sum_block = 0
            for n in range(len(self.block)):
                sum_block += self.block[n]
                if c < sum_block:
                    Number_siding.append(n)
                    break

        # n is used for create many "one_detail", otherwise all "one_schedule" will be the same
        n = 1
        temp = 0
        np.random.seed()
        self.speed[1] = np.random.normal(3, 0.5)
        self.weight[1] = np.random.randint(1, 4)
        # self.distance[1] = 0
        headway = np.random.normal(self.headway_exp, self.headway_dev)
        while True:
            # initialize label and color
            # plt.close('all')
            # plt.clf()
            self.labels.clear()
            self.pos_labels.clear()
            self.ncolor = []
            # default empty block to 'green'
            for i in range(len(self.pos)):
                self.ncolor.append('g')
            # default block which have siding to 'black'
            for i in Number_siding:
                self.ncolor[i] = 'black'

            # because headway > refresh time, so we need to decide if there is a new train.
            if temp < headway:
                temp += self.refresh
            else:
                temp = headway % self.refresh
                self.number += 1
                self.speed[self.number] = np.random.normal(3, 0.5)  # miles per second
                self.time[self.number] = self.begin_ticks + temp * 60
                self.weight[self.number] = np.random.randint(1, 4)

                # update the [distance] and [number of block] of the new generated train
                self.distance[self.number] += self.speed[self.number] * temp * 60

                while self.distance[self.number] < self.sum_block_dis[self.number]:
                    self.sum_block_dis[self.number] += self.block[self.cur_block[self.number]]
                    self.cur_block[self.number] += 1
                # while self.distance[self.number] > self.sum_block_dis[self.number]:
                #     self.sum_block_dis[self.number] += self.block[self.number]
                #     self.cur_block[self.number] += 1

                # headway = np.random.normal(10, 3)
                headway = np.random.normal(self.headway_exp, self.headway_dev)

            self.all_schedule[self.number] = {}

            for x in xrange(1, self.number + 1):
                i = rank[x]
                self.one_detail = {}
                self.time[i] += self.refresh * 60

                if self.is_DoS is True:
                    # self.time[n] is (the time for a train to move) + (begin time), so self.train[1] is current time.
                    if self.DoS_begin_ticks < self.time[1] < self.DoS_end_ticks:

                        while self.distance[i] < self.sum_block_dis[i]:
                            self.sum_block_dis[i] += self.block[self.cur_block[i]]
                            self.cur_block[i] += 1

                        if self.cur_block[i] != self.DoS_block:
                            self.distance[i] += self.speed[i] * self.refresh
                    else:
                        self.distance[i] += self.speed[i] * self.refresh

                elif self.is_DoS is False:
                    self.distance[i] += self.speed[i] * self.refresh

                '''
                Traverse the rank of all train, if low rank catch up high rank, it should follow instead of surpass. 
                Unless there is a siding.
                '''
                if x > 1:
                    # The block position of prev train and current train
                    block_prev = int(self.distance[rank[x - 1]] / self.block)
                    block_curr = int(self.distance[rank[x]] / self.block)

                    if block_prev <= block_curr:
                        for n in Number_siding:
                            if block_prev == n:
                                rank[x], rank[x - 1] = rank[x - 1], rank[x]
                                self.distance[rank[x]] -= self.speed[rank[x]] * self.refresh
                                break
                            elif n == Number_siding[-1]:
                                self.distance[rank[x]] = (block_curr - 1) * self.block

                # define which block a train in. Then change the color of networkX node
                k = 0
                for m in range(len(self.pos)):
                    if self.distance[i] > m * self.block:
                        k = m
                    else:
                        break

                # set the color of train node
                self.ncolor[k] = 'r'

                if len(self.pos) > k > 0:
                    self.labels[k+1] = i
                    self.pos_labels[k+1] = self.pos[k+1]

                self.one_detail['time'] = round(self.speed[i], 2)
                self.one_detail['speed(mils/min)'] = round(self.speed[i], 2)
                self.one_detail['distance(miles)'] = round(self.distance[i], 2)
                self.one_detail['headway(mins)'] = round(headway, 2)
                self.one_detail['weight(1-3)'] = self.weight[i]
                time_standard = self.T.strftime("%Y-%m-%d %H:%M:%S", self.T.localtime(self.time[1]))
                self.one_schedule[time_standard] = self.one_detail
                self.all_schedule[i][time_standard] = self.one_schedule[time_standard]
                n += 1

            # # draw the train map
            # nx.draw_networkx_nodes(self.G, self.pos, node_color=self.ncolor, node_size=200)
            # nx.draw_networkx_labels(self.G, self.pos_labels, self.labels, font_size=10)
            # nx.draw_networkx_edges(self.G, self.pos)

            # networkX pause 0.01 seconds
            plt.pause(0.02)
            yield env.timeout(headway * 60)

    def generate_all(self):
        x = []; y = []
        for i in self.all_schedule:
            x.append([])
            y.append([])

            for j in self.all_schedule[i]:
                x[i-1].append((time.mktime(time.strptime(j, "%Y-%m-%d %H:%M:%S")) - self.begin_ticks) / 3600)
                y[i-1].append(self.all_schedule[i][j]['distance(miles)'])

            x[i-1].sort()
            y[i-1].sort()

        plt.title('Result Analysis')
        for n in range(len(x)):
            if n % 4 == 0:
                plt.plot(x[n], y[n], color='green')
            if n % 4 == 1:
                plt.plot(x[n], y[n], color='blue')
            if n % 4 == 2:
                plt.plot(x[n], y[n], color='red')
            if n % 4 == 3:
                plt.plot(x[n], y[n], color='black')

        plt.legend()
        plt.xlabel('time')
        plt.ylabel('distance')
        plt.show()

        # print self.all_schedule
        return self.all_schedule