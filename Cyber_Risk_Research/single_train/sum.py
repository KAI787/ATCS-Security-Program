import networkx as nx
import matplotlib.pyplot as plt
import simpy
import numpy as np
import time
import collections
from collections import defaultdict

def networkX_write():
    '''
    generate a network graph and output it into 'gpickle' file
    '''
    number = 120
    G = nx.MultiGraph()

    # define the position of all nodes, it should be a dictionary
    pos = {}

    for i in range(1, number+1):
        col = ((i-1) % 20) + 1 if ((i-1) // 20) % 2 == 0 else 20 - (i-1) % 20
        row = i // 20 if i % 20 != 0 else i // 20 - 1
        pos[i] = [col, row]

    nodes = []
    edges = []
    for i in range(1, number+1):
        nodes.append(i)
        if i < number:
            edges.append((i, i+1))
    siding = [15, 35, 55, 75]
    for c in siding:
        nodes.append(c)
        G.add_path((c - 1, c + 1))

    G.add_nodes_from(nodes)
    G.add_edges_from(edges)
    nx.set_node_attributes(G, pos, 'pos')
    nx.write_gpickle(G, "a.gpickle")

def networkX_read():
    '''
    read "gpickle" file
    dynamic display the node: change the color of a node from red to green every second.
    '''


    G = nx.read_gpickle("a.gpickle")
    pos = nx.get_node_attributes(G, 'pos')

    ncolor = []
    for i in range(len(pos)):
        ncolor.append('r')

    #plt.ion()
    for index in range(len(ncolor)):
        plt.cla()
        ncolor[index] = 'g'
        if index > 0:
            ncolor[index-1] = 'r'
        nx.draw_networkx_nodes(G, pos, node_color=ncolor)
        nx.draw_networkx_labels(G, pos, font_size=16)
        nx.draw_networkx_edges(G, pos)

        # plt.pause(0.01)
    #plt.ioff()
    plt.show()
    #plt.pause(0.2)
    plt.cla()
    plt.close('all')
    return

'''
# code in main class
import networkX_w_r
networkX_w_r.networkX_write()
networkX_w_r.networkX_read()
'''




class single_train:
    '''
    many trains are generated by one control point,
    here I want to output the schedule of each train.
    '''

    def __init__(self, begin, end, siding):
        # the position of siding. ps: siding is a list of integer
        self.siding = siding
        # self.block is the length of each block
        self.block = 10
        self.refresh = 2
        self.all_schedule = {}
        # begin and end are string, the format is '2018-01-01 00:00:00'
        self.begin = begin
        self.end = end
        self.T = time
        # turn begin and end into the number ticks from 1970 to now.
        self.begin_ticks = time.mktime(time.strptime(self.begin, "%Y-%m-%d %H:%M:%S"))
        self.end_ticks = time.mktime(time.strptime(self.end, "%Y-%m-%d %H:%M:%S"))
        # self.number is the number of refresh.
        self.number = 1
        # we get a new self.one_schedule after each refresh
        self.one_schedule = {}
        self.one_detail = {}
        self.speed = {}
        # distance of each train
        self.distance = collections.defaultdict(int)
        self.time = {1: self.begin_ticks}
        self.G = nx.read_gpickle("a.gpickle")
        self.pos = nx.get_node_attributes(self.G, 'pos')
        # self.labels = collections.defaultdict()
        self.labels = {}
        self.pos_labels = {}
        # define which siding that late/fast train surpass previous/slow trains
        self.isPass = defaultdict(lambda: float('inf'))
        # in order to solve problem: the number of trains is not the rank of trains. I use dict rank[n]
        self.rank = collections.defaultdict(int)
        self.weight = collections.defaultdict(int)

        # use simpy library to define the process of train system
        env = simpy.Environment()
        env.process(self.train(env))
        duration = self.end_ticks - self.begin_ticks
        env.run(until=duration)

    def train(self, env):
        # ranking is used for find which train will be surpass next
        rank = {}
        for i in range(1000):
            rank[i] = i
        # define the serial number of block which have siding
        Number_siding = []
        for c in self.siding:
            Number_siding.append(int(c / self.block))
        # n is used for create many "one_detail", otherwise all "one_schedule" will be the same
        n = 1
        temp = 0
        np.random.seed()
        self.speed[1] = np.random.normal(3, 0.5)
        headway = np.random.normal(15, 3)
        while True:
            # initialize label and color
            plt.close('all')
            self.labels.clear()
            self.pos_labels.clear()
            self.ncolor = []
            # default empty block to 'green'
            for i in range(len(self.pos)):
                self.ncolor.append('g')
            # default block which have siding to 'black'
            for i in Number_siding:
                self.ncolor[i] = 'black'

            # because headway > refresh time, so we need to decide if there is a new train.
            if temp < headway:
                temp += self.refresh
            else:
                temp = headway % self.refresh
                self.number += 1
                self.speed[self.number] = np.random.normal(3, 0.5)  # miles per second
                self.time[self.number] = self.begin_ticks
                self.weight[self.number] = np.random.randint(1, 4)
                headway = np.random.normal(10, 3)

            self.all_schedule[self.number] = {}

            for x in xrange(1, self.number):
                i = rank[x]
                self.one_detail[n] = {}
                self.time[i] += self.refresh * 60
                self.distance[i] += self.speed[i] * self.refresh

                # # late trains occupy the block which behind the previous one, unless there is a siding.
                # if i > 1 and self.distance[rank[i]] < self.isPass[rank[i]]:
                #     if self.distance[rank[i]] > self.distance[rank[i - 1]] - self.block:
                #         for c in self.siding:
                #             if self.distance[rank[i]] < c:
                #                 self.isPass[rank[i]] = c
                #                 break
                #         self.distance[rank[i]] = self.distance[rank[i] - 1] - self.block

                # elif i > 1 and self.distance[rank[i]] > self.isPass[rank[i]] and rank:
                #     rank[i] = i

                '''
                Traverse the rank of all train, if low rank catch up high rank, it should follow instead of surpass. 
                Unless there is a siding.
                '''
                if x > 1:
                    if self.distance[rank[x]] >= self.distance[rank[x - 1]] - self.block:
                        m = int(self.distance[rank[x - 1]] / self.block)
                        for n in Number_siding:
                            if m == n:
                                rank[x], rank[x - 1] = rank[x - 1], rank[x]
                                self.distance[rank[x - 1]] -= self.speed[rank[x - 1]] * self.refresh
                                break
                            elif n == Number_siding[-1]:
                                self.distance[rank[x]] = self.distance[rank[x-1]] - self.block

                # define which block a train in. Then change the color of networkX node
                k = 0
                for m in range(len(self.pos)):
                    if self.distance[i] > m * self.block:
                        k = m
                    else:
                        break

                # set the color of train node
                self.ncolor[k] = 'r'

                if len(self.pos) > k > 0:
                    self.labels[k+1] = i
                    self.pos_labels[k+1] = self.pos[k+1]

                self.one_detail[n]['speed(mils/min)'] = round(self.speed[i], 2)
                self.one_detail[n]['distance(miles)'] = round(self.distance[i], 2)
                self.one_detail[n]['headway(mins)'] = round(headway, 2)
                self.one_detail[n]['weight(1-3)'] = self.weight[i]
                time_standard = self.T.strftime("%Y-%m-%d %H:%M:%S", self.T.localtime(self.time[i]))
                self.one_schedule[time_standard] = self.one_detail[n]
                self.all_schedule[i][time_standard] = self.one_schedule[time_standard]
                n += 1

            # draw the train map
            nx.draw_networkx_nodes(self.G, self.pos, node_color=self.ncolor, node_size=200)
            nx.draw_networkx_labels(self.G, self.pos_labels, self.labels, font_size=10)
            nx.draw_networkx_edges(self.G, self.pos)

            # networkX pause 0.01 seconds
            plt.pause(0.05)
            yield env.timeout(headway * 60)

    def generate_all(self):
        return self.all_schedule

'''
# single_train
from single_train import single_train

import networkX_w_r
networkX_w_r.networkX_write()

a = single_train('2018-01-01 00:00:00', '2018-01-03 00:00:00', [200, 400, 600, 800])
print a.generate_all()
'''

class multi_dirc:
    '''
    many trains are generated by two control points,
    here I want to output the schedule of each train.
    '''

    def __init__(self, begin, end, dis_miles, buffer_list):
        # define parameters
        self.buffer = 3
        self.all_schedule_A = {}
        self.begin = begin
        self.end = end
        self.dis = dis_miles
        self.buffer_list = buffer_list
        self.T = time
        self.begin_ticks = time.mktime(time.strptime(self.begin, "%Y-%m-%d %H:%M:%S"))
        self.end_ticks = time.mktime(time.strptime(self.end, "%Y-%m-%d %H:%M:%S"))
        self.number = 1
        self.one_schedule_A = {}
        self.one_schedule_B = {}
        self.one_detail_A = {}
        self.one_detail_B = {}
        self.speed_A = {}
        self.speed_B = np.random.normal(3, 0.5)
        self.distance_A = {1: 0}
        self.time = {1: self.begin_ticks}
        env = simpy.Environment()
        env.process(self.train(env))
        duration = self.end_ticks - self.begin_ticks
        env.run(until=duration)

    def train(self, env):
        # n is used for create many "one_detail_A", otherwise all "one_schedule_A" will be the same
        n = 0
        index_A = 0
        index_B = len(self.buffer_list)

        while True:
            np.random.seed()
            self.speed_A[self.number] = np.random.normal(3, 0.5) # miles per minute
            headway = np.random.normal(50, 3)
            self.all_schedule_A[self.number] = {}
            self.time[self.number] = self.begin_ticks
            self.distance_A[self.number] = 0

            for i in xrange(1, self.number+1):
                self.one_detail_A[n] = {}
                self.time[i] += headway * 60
                self.distance_A[i] += self.speed_A[i] * headway
                #print(i, self.distance_A[i])
                distance_B = (self.speed_B * (self.time[1] - self.begin_ticks)) / 60
                if i > 1:
                    if self.distance_A[i] > self.distance_A[i-1] - self.speed_A[i-1] * self.buffer:
                        self.distance_A[i] = self.distance_A[i-1] - self.speed_A[i-1] * self.buffer
                dirc = 'A'
                self.one_detail_A[n]['dirc'] = dirc
                self.one_detail_A[n]['speed_A(mils/min)'] = round(self.speed_A[i], 2)
                self.one_detail_A[n]['distance_A(miles)'] = round(self.distance_A[i], 2)
                self.one_detail_A[n]['headway(mins)'] = round(headway, 2)

                # get A and B pass through which buffer
                for x in range(len(self.buffer_list)):
                    if self.buffer_list[x] < self.distance_A[i]:
                        index_A = x + 1
                for x in range(len(self.buffer_list), 0):
                    if self.dis - self.buffer_list[x] < distance_B:
                        index_B = x + 1
                # A and B
                if index_B - index_A == 2:
                    time_arrive_buffer_A = self.buffer_list[index_A-1] / self.speed_A[i]
                    time_arrive_buffer_B = (self.dis - self.buffer_list[index_B-1]) / self.speed_B
                    if time_arrive_buffer_A < time_arrive_buffer_B:
                        self.distance_A[i] -= (time_arrive_buffer_B - time_arrive_buffer_A) * self.speed_A[i]
                    else:
                        distance_B -= (time_arrive_buffer_A - time_arrive_buffer_B) * self.speed_B

                self.one_detail_A[n]['buffer_index'] = index_A
                time_standard = self.T.strftime("%Y-%m-%d %H:%M:%S", self.T.localtime(self.time[i]))
                self.one_schedule_A[time_standard] = self.one_detail_A[n]
                self.all_schedule_A[i][time_standard] = self.one_schedule_A[time_standard]
                n += 1
            self.number += 1
            yield env.timeout(headway * 60)

    def generate_all(self):
        return self.all_schedule_A

'''
# code in main class

from multi_dirc import multi_dirc
a = multi_dirc('2018-01-01 00:00:00', '2018-01-02 00:00:00', 1000, [500, 1000, 1500, 2000, 2500])
print a.generate_all()
'''
