import simpy
import numpy as np
import time
import networkx as nx
import matplotlib.pyplot as plt


class single_train:
    '''
    many trains are generated by one control point,
    here I want to output the schedule of each train.
    '''

    def __init__(self, begin, end):
        self.buffer = 3
        self.block = 5
        self.refresh = 2
        self.all_schedule = {}
        self.begin = begin
        self.end = end
        self.T = time
        self.begin_ticks = time.mktime(time.strptime(self.begin, "%Y-%m-%d %H:%M:%S"))
        self.end_ticks = time.mktime(time.strptime(self.end, "%Y-%m-%d %H:%M:%S"))
        self.number = 1
        self.one_schedule = {}
        self.one_detail = {}
        self.speed = {}
        self.distance = {}
        self.time = {1: self.begin_ticks}
        self.G = nx.read_gpickle("a.gpickle")
        self.pos = nx.get_node_attributes(self.G, 'pos')
        # self.labels = collections.defaultdict()
        self.labels = {}
        self.pos_labels = {}
        env = simpy.Environment()
        env.process(self.train(env))
        duration = self.end_ticks - self.begin_ticks
        env.run(until=duration)

    def train(self, env):
        # n is used for create many "one_detail", otherwise all "one_schedule" will be the same
        n = 0
        temp = 0
        np.random.seed()
        self.speed[1] = np.random.normal(3, 0.5)
        headway = np.random.normal(15, 3)
        while True:
            # initialize label and color
            plt.close('all')
            self.labels.clear()
            self.pos_labels.clear()
            self.ncolor = []
            for i in range(len(self.pos)):
                self.ncolor.append('g')

            if temp < headway:
                temp += self.refresh
            else:
                temp = headway % self.refresh
                self.number += 1
                self.speed[self.number] = np.random.normal(3, 0.5)  # miles per second
                self.time[self.number] = self.begin_ticks
                headway = np.random.normal(15, 3)

            self.all_schedule[self.number] = {}
            for i in xrange(1, self.number + 1):
                self.one_detail[n] = {}
                self.time[i] += self.refresh * 60
                self.distance[i] = (self.speed[i] * (self.time[i] - self.begin_ticks)) / 60

                if i > 1:
                    if self.distance[i] > self.distance[i - 1] - self.speed[i - 1] * self.buffer:
                        self.distance[i] = self.distance[i - 1] - self.speed[i - 1] * self.buffer

                # dynamic color of networkX, define which block a train in
                k = 0
                for m in range(len(self.pos)):
                    if self.distance[i] > m * self.block:
                        k = m
                    else:
                        break

                # set the color of train node
                self.ncolor[k] = 'r'

                if len(self.pos) > k > 0:
                    self.labels[k+1] = i
                    self.pos_labels[k+1] = self.pos[k+1]

                self.one_detail[n]['speed(mils/min)'] = round(self.speed[i], 2)
                self.one_detail[n]['distance(miles)'] = round(self.distance[i], 2)
                self.one_detail[n]['headway(mins)'] = round(headway, 2)
                time_standard = self.T.strftime("%Y-%m-%d %H:%M:%S", self.T.localtime(self.time[i]))
                self.one_schedule[time_standard] = self.one_detail[n]
                self.all_schedule[i][time_standard] = self.one_schedule[time_standard]
                n += 1
                plt.pause(0.1)
            # print self.pos_labels
            # draw the train map
            nx.draw_networkx_nodes(self.G, self.pos, node_color=self.ncolor, node_size=200)
            nx.draw_networkx_labels(self.G, self.pos_labels, self.labels, font_size=10)
            nx.draw_networkx_edges(self.G, self.pos)
            # t += 5 * 60  # five minutes


            # networkX pause 0.1 seconds
            plt.pause(0.1)
            yield env.timeout(headway * 60)

    def generate_all(self):
        return self.all_schedule
